package bgu.spl.net.impl.stomp;

import bgu.spl.net.api.StompMessagingProtocol;
import bgu.spl.net.srv.Connections;
import bgu.spl.net.srv.ConnectionsImpl;


import java.util.concurrent.ConcurrentHashMap;

public class StompMessagingProtocolImpl implements StompMessagingProtocol<String> {

    //filed
    private int connectionId;
    private Connections<String> connections;
    private boolean shouldTerminate;

    private static ConcurrentHashMap<String, String> registeredUsers = new ConcurrentHashMap<>();
    private static ConcurrentHashMap<String, ConcurrentHashMap<Integer, String>> subscriptions = new ConcurrentHashMap<>();
    private static ConcurrentHashMap<String, Integer> activeConnections = new ConcurrentHashMap<>();


    //functions
    @Override
    public void start(int connectionId, Connections<String> connections) {
        this.connectionId = connectionId;
        this.connections = connections;
        this.shouldTerminate = false;
    }
    @Override
    public boolean shouldTerminate() {
        return shouldTerminate;
    }
    @Override
    public void process(String message) {
        String[] lines = message.split("\n");
        String command = lines[0];

        switch (command) {
            case "CONNECT":
                processConnect(lines);
                break;         
            case "SEND":
                processSend(lines);
                break;
            case "SUBSCRIBE":
                processSubscribe(lines);
                break;
            case "UNSUBSCRIBE":
                processUnsubscribe(lines);
                break;
            case "DISCONNECT":
                processDisconnect(lines);
                break;
            default:
                handleError("Unknown command: " + command, null);
                break;
        }
    }
    // process commands impl
    private void processConnect(String[] lines) {
        String username = null;
        String password = null;

        for (String line : lines) {
            if (line.startsWith("login:")) {
                username = line.substring(6);
            } else if (line.startsWith("passcode:")) {
                password = line.substring(9);
            }
        }

        if (registeredUsers.containsKey(username)) {
            if (!registeredUsers.get(username).equals(password)) {
                handleError("Wrong password", null);
                return;
            }
            if (activeConnections.containsKey(username)) {
                handleError("User already logged in", null);
                return;
            }
        } else {
            registeredUsers.put(username, password);
        }
        activeConnections.put(username, connectionId);

        String connectedFrame = "CONNECTED\nversion:1.2\n\n\u0000";

        //צריך עוד לבנות את פונקציית השליחה הזו בצורה נכונה 
        //עדיין לא כתבתי את send היא ב ConnectionsImpl<T>
        ConnectionsImpl.send(connectionId, connectedFrame);
    }
    private void processSend(String[] lines) {

        String destination = null;
        String user = null;
        StringBuilder body = new StringBuilder();
        boolean isBody = false;

        for (String line : lines) {
            if (line.startsWith("destination:")) {
                destination = line.substring(12);
            } else if (line.startsWith("user:")) {
                user = line.substring(5);
            } else if (line.isEmpty()) {
                isBody = true; 
            } else if (isBody) {
                body.append(line).append("\n");
            }
        }

        if (destination == null) {
            handleError("Missing destination header", null);
            return;
        }

        if (!subscriptions.containsKey(destination)) {
            handleError("No subscribers for destination: " + destination, null);
            return;
        }

        String messageFrame = String.format(
            "MESSAGE\ndestination:%s\n\n%s\u0000",
            destination,
            body.toString()
        );
        //צריך עוד לבנות את פונקציית השליחה הזו בצורה נכונה 
        //עדיין לא כתבתי את send היא ב ConnectionsImpl<T>
        ConnectionsImpl.send(destination, messageFrame);
    }
    private void processSubscribe(String[] lines) {
        String destination = null;
        String subscriptionId = null;
        String receiptId = null;

        for (String line : lines) {
            if (line.startsWith("destination:")) {
            destination = line.substring(12);
        } else if (line.startsWith("id:")) {
            subscriptionId = line.substring(3); 
        } else if (line.startsWith("receipt:")) {
            receiptId = line.substring(8); 
        }
        }

        if (destination == null || id == null) {
            handleError("Missing destination or id header", receiptId);
            return;
        }

        subscriptions.putIfAbsent(destination, new ConcurrentHashMap<>());
        subscriptions.get(destination).put(connectionId, subscriptionId);

        sendReceipt(connectionId, receiptId);

        System.out.println("Joined channel " + destination);

    }
    private void sendReceipt(int connectionId, String receiptId) {
        if (receiptId != null && !receiptId.isEmpty()) {
            String receiptFrame = String.format("RECEIPT\nreceipt-id:%s\n\n\u0000", receiptId);
            ConnectionsImpl.send(connectionId, receiptFrame);
        }
    }   
    private void processUnsubscribe(String[] lines) {
        String subscriptionId = null;
        String receiptId = null;

        for (String line : lines) {
        if (line.startsWith("id:")) {
            subscriptionId = line.substring(3);
        } else if (line.startsWith("receipt:")) {
            receiptId = line.substring(8);}
        }

        if (subscriptionId == null) {
        handleError("Missing subscription id header", receiptId);
        return;
        }

        boolean removed = false;

        for (String destination : subscriptions.keySet()) {
        ConcurrentHashMap<Integer, String> subscribers = subscriptions.get(destination);

        if (subscribers.containsKey(connectionId) && subscribers.get(connectionId).equals(subscriptionId)) {
            subscribers.remove(connectionId);
            removed = true;
            System.out.println("Exited channel " + destination);
            break;
        }

        if (!removed) {
        handleError("Subscription ID not found: " + subscriptionId, receiptId);
        return;
        }

        sendReceipt(connectionId, receiptId);
    }
    private void processDisconnect(String[] lines) {
        String receiptId = null;

        for (String line : lines) {
        if (line.startsWith("receipt:")) {
            receiptId = line.substring(8);}
        }
        if (receiptId == null || receiptId.isEmpty()) {
        handleError("Missing receipt header in DISCONNECT frame", receiptId);
        return;}

        subscriptions.forEach((destination, subscribers) -> subscribers.remove(connectionId));
        sendReceipt(connectionId, receiptId);
        shouldTerminate = true;
        System.out.println("Client with connectionId " + connectionId + " has disconnected.");
    }
    private void handleError(String errorMessage, String receiptId) {

        StringBuilder errorFrame = new StringBuilder();

        errorFrame.append("ERROR\n");

        errorFrame.append("message:").append(errorMessage).append("\n");

        if (receiptId != null && !receiptId.isEmpty()) {
        errorFrame.append("receipt-id:").append(receiptId).append("\n");
        }

        errorFrame.append("\n\u0000");
        ConnectionsImpl.send(connectionId, errorFrame.toString());
        shouldTerminate = true;

    }

}
